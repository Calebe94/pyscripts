#!/usr/bin/python

"""
    Ideia: No dmenu, quando for inserido notes add nome_do_arquivo deverá ser criado um arquivo
    Markdown dentro da pasta Notes na minha pasta Home. Porém, se for inserido uma subpasta, também
    chamada de "Notebook" da seguinte forma:

        note add Nome_da_Pasta/Nome_do_arquivo

    Lembrando que pode ser inserido nomes com espaço, e o script deve interpretar e poder criar,
    as pastas e arquivos sem problema. Forma de uso com espaço:

        note add Nome da Pasta/Nome do arquivo
"""

import os
import datetime
import subprocess
import argparse
import dmenu
import glob

YAML='---\ntitle: "{0}"\nsubtitle: "{1}"\ndate: "{2}"\ntags: {3}\n---'

def dmenu_show(items):
    return dmenu.show(
        items,
        prompt="Notes",
        background='#1c1f25',
        foreground='#f3f4f5',
        background_selected='#BD93F9',
        foreground_selected='#f3f4f5',
        font="San Francisco Display:size=12"
        )

def open_note(note):
    subprocess.Popen(['xdg-open', note])

def delete_note(path):
    to_return = False
    try:
        os.remove(path)
        to_return = True
    except Exception as exception:
        print(exception)
    
    return to_return

def list_notes(path):
    notes = list()

    for root, dirs, files in os.walk(path, topdown=False):
        for name in files:
            notes.append(os.path.join(root, name).replace(path+'/', ''))

    return notes

def list_notes_dirs(path):
    notes_dirs = list()

    for root, dirs, files in os.walk(path, topdown=False):
        for name in dirs:
            notes_dirs.append(os.path.join(root, name).replace(path+'/', ''))

    return notes_dirs

def add_note(path, title_name, subtitle=str(), tags=list()):
    subtitle = subtitle if subtitle != None else ''
    tags = tags if tags != None else []
    file_path = str()
    
    filename = os.path.basename(os.path.join(path, title_name))+".md"
    path = os.path.abspath(os.path.join(path, title_name))

    if not os.path.isdir(path):
        os.makedirs(path)

    file_path = os.path.join(path, filename)

    with open(file_path, 'w') as note:
        note.write(
            YAML.format(
                filename, 
                subtitle, 
                datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S'), tags)
            )

    return file_path

def dmenu_show_notes(path):
    items = list_notes(path)
    items.insert(0, "[cancel]")
    items.insert(1, "[back]")
    items.insert(2, "[add]")

    selected=dmenu_show(items)

    if os.path.isdir(os.path.join(path, selected)):
        selected = list_notes(os.path.join(path, selected))
    elif selected == "[back]":
        selected = dmenu_show_notes(os.path.join(path, "../"))
    elif selected == "[cancel]":
        pass
    elif selected in "[add]":
        selected=dmenu_show(list_notes_dirs(path))
        while os.path.isdir(os.path.join(path, selected)):
            path = os.path.join(path, selected)
            selected=dmenu_show(list_notes_dirs(path))
        note = add_note(path, title_name=selected)
        open_note(note)

    elif "add" in selected:
        title = str()
        title = selected.replace("add ", "")

        note = add_note(path, title_name=title)
        open_note(note)
    else:
        open_note(os.path.join(path, selected))

    return selected

def cli_show_notes(path):
    notes = list_notes(path)

    for note in notes:
        print(note)

def cli_delete_notes(path):
    print("Removing {} note.".format(path))
    if delete_note(path):
        print("Note deleted!")
    else:
        print("Error during process!")

def cli_arguments():
    parser = argparse.ArgumentParser()

    parser.add_argument(
        '--dmenu',
        required=False,
        help='Shows with dmenu',
        action='store_true'
        )

    parser.add_argument(
        '-a',
        '--add',
        required=False,
        help='Add note'
        )

    parser.add_argument(
        '-s',
        '--sub',
        required=False,
        help='Add subtitle to note'
        )

    parser.add_argument(
        '-t',
        '--tags',
        required=False,
        help='Add tags to note'
        )

    parser.add_argument(
        '-l',
        '--list',  
        action='store_true',
        default=False,
        required=False
    )

    parser.add_argument(
        '-p',
        '--path',
        help='Inform path to notes folder',
        default=os.path.join(os.getenv('HOME'), 'Notes'),
        required=False
    )

    parser.add_argument(
        '-d',
        '--delete',
        required=False,
        help='Remove note'
        )

    return parser

def main():
    parser = cli_arguments()
    args = parser.parse_args()
    PATH=os.path.join(os.getenv('HOME'), 'Notes')

    if args.path:
        PATH=os.path.join(args.path)

    if args.list:
        cli_show_notes(PATH)

    elif args.add:
        note = add_note(PATH, args.add, args.sub, args.tags)
        subprocess.Popen(['xdg-open', note])
    elif args.dmenu:
        dmenu_show_notes(PATH)
    elif args.delete:
        cli_delete_notes(args.delete)
    else:
        parser.print_help()
        parser.exit()

if __name__ == "__main__":
    main()