#!/usr/bin/python

"""
    Ideia: No dmenu, quando for inserido notes add nome_do_arquivo deverá ser criado um arquivo
    Markdown dentro da pasta Notes na minha pasta Home. Porém, se for inserido uma subpasta, também
    chamada de "Notebook" da seguinte forma:

        note add Nome_da_Pasta/Nome_do_arquivo

    Lembrando que pode ser inserido nomes com espaço, e o script deve interpretar e poder criar,
    as pastas e arquivos sem problema. Forma de uso com espaço:

        note add Nome da Pasta/Nome do arquivo
"""

import os
import datetime
import subprocess
import argparse
import dmenu
import glob

YAML='---\ntitle: "{0}"\nsubtitle: "{1}"\ndate: "{2}"\ntags: {3}\n---'

def dmenu_show(items):
    return dmenu.show(
        items,
        prompt="Notes",
        background='#1c1f25',
        foreground='#f3f4f5',
        background_selected='#BD93F9',
        foreground_selected='#f3f4f5',
        font="San Francisco Display:size=12"
        )

def open_note(note):
    subprocess.Popen(['xdg-open', note])

def list_notes(path):
    notes = list()

    for root, dirs, files in os.walk(path, topdown=False):
        for name in files:
            notes.append(os.path.join(root, name).replace(path+'/', ''))

    return notes

def list_notes_dirs(path):
    notes_dirs = list()

    for root, dirs, files in os.walk(path, topdown=False):
        for name in dirs:
            notes_dirs.append(os.path.join(root, name).replace(path+'/', ''))

    return notes_dirs

def add_note(path, title_name, subtitle=str(), tags=list()):
    subtitle = subtitle if subtitle != None else ''
    tags = tags if tags != None else []
    file_path = str()
    
    filename = os.path.basename(os.path.join(path, title_name))+".md"
    path = os.path.abspath(os.path.join(path, title_name))

    if not os.path.isdir(path):
        os.makedirs(path)

    file_path = os.path.join(path, filename)

    with open(file_path, 'w') as note:
        note.write(YAML.format(filename, subtitle, datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S'), tags))

    return file_path

def cli_show_notes(path):
    notes = list_notes(path)

    for note in notes:
        print(note)

def cli_arguments():
    parser = argparse.ArgumentParser()

    parser.add_argument(
        '-a',
        '--add',
        required=False,
        help='Add note'
        )

    parser.add_argument(
        '-s',
        '--sub',
        required=False,
        help='Add subtitle to note'
        )

    parser.add_argument(
        '-t',
        '--tags',
        required=False,
        help='Add tags to note'
        )

    parser.add_argument(
        '-l',
        '--list',
        action='store_true',
        default=False,
        required=False
    )

    parser.add_argument(
        '-p',
        '--path',
        help='Inform path to notes folder',
        default=os.path.join(os.getenv('HOME'), 'Notes'),
        required=False
    )

    return parser

def main():
    parser = cli_arguments()
    args = parser.parse_args()
    PATH=os.path.join(os.getenv('HOME'), 'Notes')

    if args.path:
        PATH=os.path.join(args.path)

    if args.list:
        cli_show_notes(PATH)
    elif args.add:
        note = add_note(PATH, args.add, args.sub, args.tags)
        subprocess.Popen(['xdg-open', note])
    else:
        parser.print_help()
        parser.exit()

if __name__ == "__main__":
    main()